function besk0 ( x )
  use kindmod
!*****************************************************************************80
!
!! BESK0 evaluates the modified Bessel K function of order 0.
!
!  Discussion:
!
!    This function computes approximate values for the
!    modified Bessel function of the second kind of order zero
!    for arguments 0.0 < ARG <= XMAX.  See comments heading
!    CALCK0.
!
!  Modified:
!
!    10 January 2016
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
  implicit none

  real ( kind = dp ):: besk0
  integer :: jint
  real ( kind = dp ):: x, result

  jint = 1
  call calck0 ( x, result, jint )
  besk0 = result

  return
end
function besk1 ( x )

!*****************************************************************************80
!
!! BESK1 evaluates the modified Bessel K function of order 1.
!
!  Discussion:
!
!    This function computes approximate values for the
!    modified Bessel function of the second kind of order one
!    for arguments XLEAST <= ARG <= XMAX.
!
!  Modified:
!
!    10 January 2016
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
  implicit none

  real ( kind = 8 ) besk1
  integer ( kind = 4 ) jint
  real ( kind = 8 ) x, result

  jint = 1
  call calck1(x,result,jint)
  besk1 = result

  return
end

subroutine calck0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK0 evaluates modified Bessel K functions of order 0.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order zero, K0(X) and EXP(X)*K0(X), for real
!    arguments X.  It contains two function type subprograms, BESK0
!    and BESEK0, and one subroutine type subprogram, CALCK0.
!    the calling statements for the primary entries are
!
!       Y=BESK0(X)
!   and
!       Y=BESEK0(X)
!
!   where the entry points correspond to the functions K0(X) and
!   EXP(X)*K0(X), respectively.  The routine CALCK0 is
!   intended for internal packet use only, all computations within
!   the packet being concentrated in this routine.  The function
!   subprograms invoke CALCK0 with the statement
!      CALL CALCK0(ARG,RESULT,JINT)
!   where the parameter usage is as follows
!
!  function         Parameters for CALCK0
!   Call      ARG      RESULT      JINT
!
!     BESK0(ARG)   0 < ARG <= XMAX   K0(ARG)       1
!     BESEK0(ARG)     0 < ARG       EXP(ARG)*K0(ARG)     2
!
!   The main computation evaluates slightly modified forms of near
!   minimax rational approximations generated by Russon and Blair,
!   Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!   1969.  This transportable program is patterned after the
!   machine-dependent FUNPACK packet NATSK0, but cannot match that
!   version for efficiency or accuracy.  This version uses rational
!   functions that theoretically approximate K-SUB-0(X) to at
!   least 18 significant decimal digits.  The accuracy achieved
!   depends on the arithmetic system, the compiler, the intrinsic
!   functions, and proper selection of the machine-dependent
!   constants.
!
!  Modified:
!
!    10 January 2016
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
! Explanation of machine-dependent constants.  Let
!
!   beta   = Radix for the floating-point system
!   minexp = Smallest representable power of beta
!   maxexp = Smallest power of beta that overflows
!
! Then the following machine-dependent constants must be declared
!   in DATA statements.  IEEE values are provided as a default.
!
!   XSMALL = Argument below which BESK0 and BESEK0 may
!    each be represented by a constant and a log.
!    largest X such that  1.0 + X = 1.0  to machine
!    precision.
!   XINF   = Largest positive machine number; approximately
!    beta**maxexp
!   XMAX   = Largest argument acceptable to BESK0;  Solution to
!    equation:
!       W(X) * (1-1/8X+9/128X**2) = beta**minexp
!    where  W(X) = EXP(-X)*SQRT(PI/2X)
!
! Error returns
!
!  The program returns the value XINF for ARG <= 0.0, and the
!  BESK0 entry returns the value 0.0 for ARG > XMAX.
!
  use kindmod
  implicit none

  integer :: i,jint
  real ( kind = dp ):: &
      arg,f,g,one,p,pp,q,qq,result,sumf,sumg,sump,sumq,temp, &
      x,xinf,xmax,xsmall,xx,zero
  dimension p(6),q(2),pp(10),qq(10),f(4),g(3)
!
!  Mathematical constants
!
  data one/1.0d0/,zero/0.0d0/
!
!  Machine-dependent constants
!
  data xsmall/1.11d-16/,xinf/1.79d+308/,xmax/705.342d0/
!
!  Coefficients for XSMALL <=  ARG  <= 1.0
!
  data   p/ 5.8599221412826100000d-04, 1.3166052564989571850d-01, &
        1.1999463724910714109d+01, 4.6850901201934832188d+02, &
        5.9169059852270512312d+03, 2.4708152720399552679d+03/
  data   q/-2.4994418972832303646d+02, 2.1312714303849120380d+04/
  data   f/-1.6414452837299064100d+00,-2.9601657892958843866d+02, &
       -1.7733784684952985886d+04,-4.0320340761145482298d+05/
  data   g/-2.5064972445877992730d+02, 2.9865713163054025489d+04, &
       -1.6128136304458193998d+06/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 1.1394980557384778174d+02, 3.6832589957340267940d+03, &
        3.1075408980684392399d+04, 1.0577068948034021957d+05, &
        1.7398867902565686251d+05, 1.5097646353289914539d+05, &
        7.1557062783764037541d+04, 1.8321525870183537725d+04, &
        2.3444738764199315021d+03, 1.1600249425076035558d+02/
  data  qq/ 2.0013443064949242491d+02, 4.4329628889746408858d+03, &
        3.1474655750295278825d+04, 9.7418829762268075784d+04, &
        1.5144644673520157801d+05, 1.2689839587977598727d+05, &
        5.8824616785857027752d+04, 1.4847228371802360957d+04, &
        1.8821890840982713696d+03, 9.2556599177304839811d+01/

  x = arg

  if (x > zero) then

    if (x <= one) then
!
!  0.0 <  ARG  <= 1.0
!
      temp = log(x)

      if (x < xsmall) then
!
!  Return for small ARG
!
        result = p(6)/q(2) - temp

      else

        xx = x * x
        sump = ((((p(1)*xx + p(2))*xx + p(3))*xx + &
          p(4))*xx + p(5))*xx + p(6)
        sumq = (xx + q(1))*xx + q(2)
        sumf = ((f(1)*xx + f(2))*xx + f(3))*xx + f(4)
        sumg = ((xx + g(1))*xx + g(2))*xx + g(3)
        result = sump/sumq - xx*sumf*temp/sumg - temp
        if (jint == 2) result = result * exp(x)

      end if

    else if ((jint == 1) .and. (x > xmax)) then
!
!  Error return for ARG > XMAX
!
      result = zero

    else
!
!  1.0 < ARG
!
      xx = one / x
      sump = pp(1)
      do i = 2, 10
        sump = sump*xx + pp(i)
      end do
      sumq = xx
      do i = 1, 9
        sumq = (sumq + qq(i))*xx
      end do
      sumq = sumq + qq(10)
      result = sump / sumq / sqrt(x)
      if (jint == 1) result = result * exp(-x)

    end if

  else
!
!  Error return for ARG <= 0.0
!
    result = xinf

  end if

  return
end
subroutine calck1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK1 evaluates modifies Bessel K functions of order 1.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order one,  K1(X)  and  EXP(X)*K1(X), for real arguments X.
!    It contains two function type subprograms, BESK1  and  BESEK1,
!    and one subroutine type subprogram, CALCK1.  The calling
!    statements for the primary entries are
!
!       Y=BESK1(X)
!   and
!       Y=BESEK1(X)
!
!   where the entry points correspond to the functions K1(X) and
!   EXP(X)*K1(X), respectively.  The routine CALCK1 is intended
!   for internal packet use only, all computations within the
!   packet being concentrated in this routine.  The function
!   subprograms invoke CALCK1 with the statement
!      CALL CALCK1(ARG,RESULT,JINT)
!   where the parameter usage is as follows
!
!    function          Parameters for CALCK1
!    Call     ARG      RESULT      JINT
!
!     BESK1(ARG)  XLEAST < ARG < XMAX    K1(ARG)      1
!     BESEK1(ARG)     XLEAST < ARG   EXP(ARG)*K1(ARG)    2
!
!   The main computation evaluates slightly modified forms of near
!   minimax rational approximations generated by Russon and Blair,
!   Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!   1969.  This transportable program is patterned after the
!   machine-dependent FUNPACK packet NATSK1, but cannot match that
!   version for efficiency or accuracy.  This version uses rational
!   functions that theoretically approximate K-SUB-1(X) to at
!   least 18 significant decimal digits.  The accuracy achieved
!   depends on the arithmetic system, the compiler, the intrinsic
!   functions, and proper selection of the machine-dependent
!   constants.
!
!  Modified:
!
!    10 January 2016
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
! Explanation of machine-dependent constants.  Let
!
!   beta   = Radix for the floating-point system
!   minexp = Smallest representable power of beta
!   maxexp = Smallest power of beta that overflows
!
! Then the following machine-dependent constants must be declared
!   in DATA statements.  IEEE values are provided as a default.
!
!   XLEAST = Smallest acceptable argument, i.e., smallest machine
!    number X such that 1/X is machine representable.
!   XSMALL = Argument below which BESK1(X) and BESEK1(X) may
!    each be represented by 1/X.  A safe value is the
!    largest X such that  1.0 + X = 1.0  to machine
!    precision.
!   XINF   = Largest positive machine number; approximately
!    beta**maxexp
!   XMAX   = Largest argument acceptable to BESK1;  Solution to
!    equation:
!       W(X) * (1+3/8X-15/128X**2) = beta**minexp
!    where  W(X) = EXP(-X)*SQRT(PI/2X)
!
! Error returns
!
!  The program returns the value XINF for ARG <= 0.0 and the
!   BESK1 entry returns the value 0.0 for ARG > XMAX.
!
  implicit none

  integer ( kind = 4 ) i,jint
  real ( kind = 8 ) &
      arg,f,g,one,p,pp,q,qq,result,sumf,sumg, &
      sump,sumq,x,xinf,xmax,xleast,xsmall,xx,zero
  dimension p(5),q(3),pp(11),qq(9),f(5),g(3)
!
!  Mathematical constants
!
  data one/1.0d0/,zero/0.0d0/
!
!  Machine-dependent constants
!
  data xleast/2.23d-308/,xsmall/1.11d-16/,xinf/1.79d+308/, &
       xmax/705.343d+0/
!
!  Coefficients for  XLEAST <=  ARG  <= 1.0
!
  data   p/ 4.8127070456878442310d-1, 9.9991373567429309922d+1, &
        7.1885382604084798576d+3, 1.7733324035147015630d+5, &
        7.1938920065420586101d+5/
  data   q/-2.8143915754538725829d+2, 3.7264298672067697862d+4, &
       -2.2149374878243304548d+6/
  data   f/-2.2795590826955002390d-1,-5.3103913335180275253d+1, &
       -4.5051623763436087023d+3,-1.4758069205414222471d+5, &
       -1.3531161492785421328d+6/
  data   g/-3.0507151578787595807d+2, 4.3117653211351080007d+4, &
       -2.7062322985570842656d+6/
!
!  Coefficients for  1.0 <  ARG
!
  data  pp/ 6.4257745859173138767d-2, 7.5584584631176030810d+0, &
        1.3182609918569941308d+2, 8.1094256146537402173d+2, &
        2.3123742209168871550d+3, 3.4540675585544584407d+3, &
        2.8590657697910288226d+3, 1.3319486433183221990d+3, &
        3.4122953486801312910d+2, 4.4137176114230414036d+1, &
        2.2196792496874548962d+0/
  data  qq/ 3.6001069306861518855d+1, 3.3031020088765390854d+2, &
        1.2082692316002348638d+3, 2.1181000487171943810d+3, &
        1.9448440788918006154d+3, 9.6929165726802648634d+2, &
        2.5951223655579051357d+2, 3.4552228452758912848d+1, &
        1.7710478032601086579d+0/

  x = arg

  if (x < xleast) then
!
!  Error return for  ARG  < XLEAST
!
    result = xinf

  else if (x <= one) then
!
!  XLEAST <=  ARG  <= 1.0
!
    if (x < xsmall) then
!
!  Return for small ARG
!
      result = one / x

    else

      xx = x * x
      sump = ((((p(1)*xx + p(2))*xx + p(3))*xx + p(4))*xx + p(5))*xx + q(3)
      sumq = ((xx + q(1))*xx + q(2))*xx + q(3)
      sumf = (((f(1)*xx + f(2))*xx + f(3))*xx + f(4))*xx + f(5)
      sumg = ((xx + g(1))*xx + g(2))*xx + g(3)
      result = (xx * log(x) * sumf/sumg + sump/sumq) / x
      if (jint == 2) result = result * exp(x)

    end if

  else if ((jint == 1) .and. (x > xmax)) then
!
!  Error return for  ARG  > XMAX
!
    result = zero

  else
!
!  1.0 <  ARG
!
    xx = one / x

    sump = pp(1)
    do i = 2, 11
      sump = sump * xx + pp(i)
    end do

    sumq = xx
    do i = 1, 8
      sumq = (sumq + qq(i)) * xx
    end do
    sumq = sumq + qq(9)

    result = sump / sumq / sqrt(x)
    if (jint == 1) result = result * exp(-x)

  end if

  return
end

